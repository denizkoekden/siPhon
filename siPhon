#!/usr/bin/python3

##############################################################################
### siPhon: A tool for access to data in iPods or other poorly-formed sets of
### audio files.  It tries to make no assumptions about the arrangement of the
### information.  You can use it on your files recovered from a formatted drive
### if you like, and as long as they were tagged, it will probably make some
### sense of them.
##################################################
#### Chris Smith, 2022
#### Deniz K., 2024 - Cleanup the code
##################################################

import os, sys, re
import shutil
import argparse
import pickle
import mutagen
import magic
from tqdm import tqdm

ap = argparse.ArgumentParser()
ap.set_defaults(song=None, album=None, artist=None, cmd=None) 
ap.add_argument('-i', '--base', required=True, help="Location of iPod")
ap.add_argument('--db', help="Location of database")
sp = ap.add_subparsers(title="Commands", help="Specify <command> -h for help on a command.")
p_scan = sp.add_parser('scan', help="Scan device for music and write database.", aliases=['init', 'index'])
p_scan.set_defaults(cmd='scan')
p_clean = sp.add_parser('clean', help="Remove database generated by 'scan'.")
p_clean.set_defaults(cmd='clean')
p_artists = sp.add_parser('artists', help="List artists in database.", aliases=['artist', 'art'])
p_artists.set_defaults(cmd='artists')
p_albums = sp.add_parser('albums', help="List albums in database.", aliases=['album', 'alb'])
p_albums.set_defaults(cmd='albums')
p_list = sp.add_parser('list', help="List music in database.", aliases=['dir', 'ls'])
p_list.add_argument('-a', '--artist', help="Filter by artist")
p_list.add_argument('-A', '--album', help="Filter by album")
p_list.add_argument('-s', '-t', '--song', '--track', help="Filter by track name")
p_list.set_defaults(cmd='list')
p_get = sp.add_parser('get', help="Copy music from the device.", aliases=['extract', 'cp', 'copy'])
p_get.add_argument('-a', '--artist', help="Filter by artist")
p_get.add_argument('-A', '--album', help="Filter by album")
p_get.add_argument('-s', '-t', '--song', '--track', help="Filter by track name")
p_get.add_argument('-d', '-o', '--dest', '--out', required=True, help="Base directory for output.")
p_get.set_defaults(cmd='get')

args = ap.parse_args()

INVALID_CHARS = r'<>:"/\\|?*'
MAX_PATH_LENGTH = 260

def writedb():
    rv = True
    try:
        if not os.path.exists(dbDir):
            os.mkdir(dbDir)
        with open(dbAlbums, 'wb') as albF, open(dbArtists, 'wb') as artF, open(dbSongs, 'wb') as songF, open(dbFiles, 'wb') as fileF:
            pickle.dump(Albums, albF)
            pickle.dump(Artists, artF)
            pickle.dump(Songs, songF)
            pickle.dump(Files, fileF)
    except Exception as e:
        print("Can't write database:", e)
        rv = False
    return rv

def readdb():
    global Albums, Artists, Songs, Files
    rv = True
    try:
        with open(dbAlbums, 'rb') as albF, open(dbArtists, 'rb') as artF, open(dbSongs, 'rb') as songF, open(dbFiles, 'rb') as fileF:
            Albums = pickle.load(albF)
            Artists = pickle.load(artF)
            Songs = pickle.load(songF)
            Files = pickle.load(fileF)
    except Exception as e:
        print("Can't read database. Try scan first.", e)
        rv = False
    return rv

def rmdb():
    rv = True
    if args.db:
        print("Won't clean a database specified on the command-line. Delete it manually.")
        return False
    try:
        os.unlink(dbAlbums)
        os.unlink(dbArtists)
        os.unlink(dbSongs)
        os.unlink(dbFiles)
        os.rmdir(dbDir)
    except Exception as e:
        rv = False
    return rv

# Clean up tags
def tsanitize(st):
    st = str(st)
    st = re.sub(r"^\['", '', st)
    st = re.sub(r'^\["', '', st)
    st = re.sub(r"'\]$", '', st)
    st = re.sub(r'"\]$', '', st)
    st = re.sub(r"^\s+", '', st)
    st = re.sub(r"\s+$", '', st)
    return st

# Clean up filenames
def fsanitize(st):
    st = re.sub(r'[<>:"/\\|?*]', '', st)
    st = re.sub(r'\s+$', '', st)
    st = re.sub(r'^\s+', '', st)
    return st

def safe_path(base, *paths):
    path = os.path.join(base, *paths)
    if len(path) > MAX_PATH_LENGTH:
        path = path[:MAX_PATH_LENGTH - 1]
    return path

def scan():
    os.chdir(args.base)
    for base, dirs, files in os.walk("."):
        for file in (progress := tqdm(files)):
            m = ""
            fn = os.path.join(base, file)
            progress.set_description(fn)
            try:
                m = magic.from_file(fn)
            except Exception as e:
                pass
            if re.search('audio', m, re.IGNORECASE):
                if re.search('alac', m, re.IGNORECASE) or re.search('aac', m, re.IGNORECASE):
                    fmt = 'm4a'
                else: 
                    fmt = 'mp3'
                try:
                    tags = mutagen.File(fn)
                except:
                    pass
                if tags:
                    album = "Unknown Album"
                    artist = "Unknown"
                    trnum = ""
                    trnam = "Untitled"
                    if 'TRCK' in tags:
                        trnum = tags['TRCK']
                    elif 'trkn' in tags:
                        trnum = str(tags['trkn'])	
                    if 'TIT2' in tags:
                        trnam = str(tags['TIT2'])
                    elif '©nam' in tags:
                        trnam = str(tags['©nam'])
                    if 'TALB' in tags:
                        album = str(tags['TALB'])
                    elif '©alb' in tags:
                        album = str(tags['©alb'])
                    if 'TPE1' in tags:
                        artist = str(tags['TPE1'])
                    elif '©ART' in tags:
                        artist = str(tags['©ART'])

                    artist = tsanitize(artist)
                    album = tsanitize(album)
                    trnam = tsanitize(trnam)
                    trnum = tsanitize(trnum)

                    trnum = re.sub(r'.*?([0-9]+).*', r"\1", trnum)

                    if trnam not in Songs:
                        Songs[trnam] = []
                    if artist not in Artists:
                        Artists[artist] = []
                    if album not in Albums:
                        Albums[album] = []
                    if fn not in Files:
                        Files[fn] = []
                    Songs[trnam].append(fn)
                    Albums[album].append(fn)
                    Artists[artist].append(fn)
                    Files[fn] = {'artist': artist, 'album': album, 'trnum': trnum, 'trnam': trnam, 'fmt': fmt}
    writedb()

def find(artist=args.artist, album=args.album, trnam=args.song):
    flist = Files
    if trnam and trnam in Songs:
        flist = [file for file in flist if file in Songs[trnam]]
    if album:
        if album not in Albums:
            print("No albums matching " + album)
            return []
        flist = [file for file in flist if file in Albums[album]]
    if artist:
        if artist not in Artists:
            print("No artists matching " + artist)
            return []
        flist = [file for file in flist if file in Artists[artist]]
    return flist

def ls():
    if not readdb():
        return False
    for file in find():
        print("Artist: " + Files[file]['artist'] + " / Album: " + Files[file]['album'])
        print("Name: " + Files[file]['trnam'] + " / File: " + file)
        print("--------")

def lsartists():
    if not readdb():
        return False
    for a in Artists.keys():
        print(a)

def lsalbums():
    if not readdb():
        return False
    for a in Albums.keys():
        print(a)

def get():
    if not readdb():
        return False
    os.chdir(args.base)
    for source in (progress := tqdm(find())): 
        f = Files[source]
        ddir = safe_path(args.dest, fsanitize(f['artist']), fsanitize(f['album']))
        dname = f"{f['trnum']}. {f['trnam']}.{f['fmt']}" if f['trnum'] else f"{f['trnam']}.{f['fmt']}"
        dname = fsanitize(dname)
        full_path = safe_path(ddir, dname)
        
        progress.set_description(full_path)
        try:
            os.makedirs(ddir, exist_ok=True)
        except Exception as e:
            print("Can't create " + ddir, e)
        try:
            shutil.copyfile(source, full_path)
        except Exception as e:
            print("Can't create " + full_path, e)

if os.path.isdir(args.base):
    if args.db:
        dbDir = args.db
    else:
        dbDir = os.path.join(args.base, "siPhon-db")
    dbArtists = os.path.join(dbDir, "artists.db")
    Artists = {}
    dbAlbums = os.path.join(dbDir, "albums.db")
    Albums = {}
    dbSongs = os.path.join(dbDir, "songs.db")
    Songs = {}
    dbFiles = os.path.join(dbDir, "files.db")
    Files = {}

    if not args.cmd:
        print("Please specify a command.")
    else:
        if args.cmd == 'scan':
            scan()
        elif args.cmd == 'clean':
            rmdb()
        elif args.cmd == 'list':
            ls()
        elif args.cmd == 'get':
            get()
        elif args.cmd == 'artists':
            lsartists()
        elif args.cmd == 'albums':
            lsalbums()
else:
    print("Root of collection not available: " + args.base)
